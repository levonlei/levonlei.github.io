<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>struct_tools</title>
    <link href="/2022/08/17/struct-tools/"/>
    <url>/2022/08/17/struct-tools/</url>
    
    <content type="html"><![CDATA[<h1 id="常用的golang-struct结构体工具"><a href="#常用的golang-struct结构体工具" class="headerlink" title=" 常用的golang struct结构体工具"></a><center> 常用的golang struct结构体工具</h1><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#menuIndex1">背景</a></li><li><a href="#menuIndex2">用法一：json to go</a></li><li><a href="#menuIndex3">用法二：yaml to go</a></li><li><a href="#menuIndex4">用法三：json to proto</a></li><li><a href="#menuIndex5">用法三：sql to go </a></li></ul><h3 id="menuIndex1">背景</h3>写go代码的时候，经常遇到读取yaml文件，调用第三方库等场景。前期自己写数据结构，后面发现自己傻了，有现成的，输入后就出现自己想要的，简直不要太爽。<h3 id="menuIndex2">json to go</h3>json数据生成go结构体<pre class="prettyprint linenums"><code><span  id="jump" class="pln">https://mholt.github.io/json-to-go/</span></code></pre><h3 id="menuIndex3">yaml to go</h3>yaml数据生成结构体<pre class="prettyprint linenums"><code><span  id="jump" class="pln">https://zhwt.github.io/yaml-to-go/</span></code></pre><h3 id="menuIndex4">json to proto</h3>json数据生成proto结构<pre class="prettyprint linenums"><code><span  id="jump" class="pln">https://json-to-proto.github.io/</span></code></pre><h3 id="menuIndex5">sql to go</h3>sql数据生成go结构体（非常好用，可以直接支持gorm使用）<pre class="prettyprint linenums"><code><span  id="jump" class="pln">https://www.qetool.com/sql_json_go/sql.html</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>golang中下划线_的用法</title>
    <link href="/2022/08/14/underline_use/"/>
    <url>/2022/08/14/underline_use/</url>
    
    <content type="html"><![CDATA[<h1 id="golang中下划线-的用法"><a href="#golang中下划线-的用法" class="headerlink" title=" golang中下划线_的用法"></a><center> golang中下划线_的用法</h1><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#menuIndex1">背景</a></li><li><a href="#menuIndex2">用法一：类型断言</a></li><li><a href="#menuIndex3">用法二：忽略返回值</a></li><li><a href="#menuIndex4">用法三：引入包</a></li></ul><h3 id="menuIndex1">背景</h3>在看很多源码的时候会出现下划线的用法，尤其是用在接口与结构体之间进行断言，kubernets，kuberbuilder之中都存在。自己总结了一下，下划线的用法，记录下来。<h3 id="menuIndex2">用法一：类型断言</h3>假设我们定义了interface<pre class="prettyprint linenums"><code><span class="pln">type Foo interface &#123;     Say()&#125;</span></code></pre>定义struct<pre class="prettyprint linenums"><code><span class="pln">type Dog struct &#123;&#125;</span></code></pre>后我们希望在代码中判断Dog这个struct是否实现了Foo这个interface，就可以如下这么写。<pre class="prettyprint linenums"><code><span class="pln">var _ Foo = Dog&#123;&#125; &#123;&#125;</span></code></pre>假设没有实现的话，ide会波浪线标识以及告诉你哪个没实现，再者编译的时候会直接报错。可以很好的帮助我们编程时候发现错误<h3 id="menuIndex3">用法二：忽略返回值</h3>假设一个函数定义了多个变量，我们只需要其中一个，其他的不要用到，就可以这么使用。这是下划线在go中最常见的用法了。<pre class="prettyprint linenums"><code><span class="pln">v1, _ := func(...) &#123;&#125;</span></code></pre><h3 id="menuIndex4">用法三：引入包</h3>假设我们在代码的import中这样引入package：<pre class="prettyprint linenums"><code><span class="pln">import _ "test/foo" &#123;&#125;</span></code></pre>这表示呢在执行本段代码之前会先调用test/foo中的初始化函数(init)，这种使用方式仅让导入的包做初始化，而不使用包中其他功能。适用于本包文件的运行，必须执行某个包的init函数，避免panic问题]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes pod 状态解析</title>
    <link href="/2022/06/17/pod%E7%8A%B6%E6%80%81/"/>
    <url>/2022/06/17/pod%E7%8A%B6%E6%80%81/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-pod-状态解析"><a href="#Kubernetes-pod-状态解析" class="headerlink" title="Kubernetes pod 状态解析"></a>Kubernetes pod 状态解析</h1><h2 id="What-is-a-pod"><a href="#What-is-a-pod" class="headerlink" title="What is a pod?"></a>What is a pod?</h2><p>全部复制到官网的<br>A pod models an application-specific “logical host(逻辑节点)” in a containerized environment. It may contain one or more containers which are relatively tightly coupled—in a pre-container world（在 pre-container 时代紧密联系的进程 ，在container 时代放在一个pod里）, they would have executed on the same physical or virtual host.a pod has a single IP address.  Multiple containers that run in a pod all share that common network name space。</p><p>Like running containers, pods are considered to be relatively ephemeral rather than durable entities. Pods are scheduled to nodes and remain there until termination (according to restart policy) or deletion. When a node dies, the pods scheduled to that node are deleted. Specific pods are never rescheduled to new nodes; instead, they must be replaced.</p><p>A pod is a relatively tightly coupled group of containers that are scheduled onto the same host.</p><ol><li>It models an application-specific(面向应用) “virtual host” in a containerized environment.</li><li>Pods serve as units of scheduling, deployment, and horizontal scaling/replication.</li><li>Pods share fate（命运）, and share some resources, such as storage volumes and IP addresses.(网络通信和数据交互就非常方便且高效)</li></ol><p>Pods can be used to host vertically integrated application stacks, but their primary motivation is to support <strong>co-located, co-managed</strong> （这两个形容词绝了）helper programs, such as:</p><ol><li>Content management systems, file and data loaders, local cache managers, etc.</li><li>Log and checkpoint backup, compression, rotation, snapshotting, etc.</li><li>Data-change watchers, log tailers, logging and monitoring adapters, event publishers, etc.</li><li>Proxies, bridges, and adapters.</li><li>Controllers, managers, configurators, and updaters.</li></ol><p><strong>Individual pods are not intended to run multiple instances of the same application</strong>, in general.</p><h2 id="为什么需要pod？"><a href="#为什么需要pod？" class="headerlink" title="为什么需要pod？"></a>为什么需要pod？</h2><p>本小节大部分来自对极客时间《深入剖析kubernetes》的学习</p><ol><li>操作系统为什么要有进程组？原因之一是 Linux 操作系统只需要将信号，比如，SIGKILL 信号，发送给一个进程组，那么该进程组中的所有进程就都会收到这个信号而终止运行。</li><li>在 Borg 项目的开发和实践过程中，Google 公司的工程师们发现，他们部署的应用，往往都存在着类似于“进程和进程组”的关系。更具体地说，就是这些应用之间有着密切的协作关系，使得它们必须部署在同一台机器上。具有“超亲密关系”容器的典型特征包括但不限于：</li></ol><ul><li>互相之间会发生直接的文件交换</li><li>使用 localhost 或者 Socket文件进行本地通信</li><li>会发生非常频繁的远程调用</li><li>需要共享某些 Linux Namespace</li></ul><ol start="3"><li>亲密关系 ==&gt; 亲密关系为什么不在调度层面解决掉？非得提出pod 的概念？<a href="https://www.usenix.org/system/files/conference/hotcloud16/hotcloud16_burns.pdf">容器设计模式</a></li><li><strong>Pod 这种“超亲密关系”容器的设计思想，实际上就是希望，当用户想在一个容器里跑多个功能并不相关的应用时，应该优先考虑它们是不是更应该被描述成一个 Pod 里的多个容器</strong>。你就可以把整个虚拟机想象成为一个 Pod，把这些进程分别做成分别做成容器镜像，把有顺序关系的容器，定义为 Init Container。 作者提到了tomcat 镜像和war 包（war包单独做一个镜像）的例子，非常精彩，好就好在 分别做镜像 肯定比 镜像做在一起要方便。<strong>重点不是pod 是什么，而是什么情况下， 我们要将多个容器放在pod 里。</strong></li><li><a href="https://cloud.google.com/container-engine/docs">https://cloud.google.com/container-engine/docs</a> Pods also simplify application deployment and management by providing a higher-level abstraction than the raw, low-level container interface. <strong>Pods serve as units of deployment and horizontal scaling/replication. Co-location, fate sharing, coordinated replication, resource sharing, and dependency management are handled automatically.</strong></li></ol><h2 id="Pod-Operations"><a href="#Pod-Operations" class="headerlink" title="Pod Operations"></a>Pod Operations</h2><h3 id="Creating-a-pod"><a href="#Creating-a-pod" class="headerlink" title="Creating a pod"></a>Creating a pod</h3><p>Pod，而不是容器，才是 Kubernetes 项目中的最小编排单位。将这个设计落实到 API 对象上，容器（Container）就成了 Pod 属性里的一个普通的字段。那么，一个很自然的问题就是：到底哪些属性属于 Pod 对象，而又有哪些属性属于 Container 呢？</p><p>Pod 扮演的是传统部署环境里“虚拟机”的角色。这样的设计，是为了使用户从传统环境（虚拟机环境）向 Kubernetes（容器环境）的迁移，更加平滑。而如果你能把 Pod 看成传统环境里的“机器”、把容器看作是运行在这个“机器”里的“用户程序”，那么很多关于 Pod 对象的设计就非常容易理解了。 比如，<strong>凡是调度、网络、存储，以及安全相关的属性，基本上是 Pod 级别的</strong>。这些属性的共同特征是，它们描述的是“机器”这个整体，而不是“机器”里的“用户程序”。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod...</span><br><span class="hljs-attr">spec:</span><br><span class="hljs-attr">nodeSelector:</span><br><span class="hljs-attr">hostAliases:</span><br><span class="hljs-attr">containers:</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span><br><span class="hljs-attr">image:</span><br><span class="hljs-attr">lifecycle:</span><br><span class="hljs-attr">postStart:</span><br><span class="hljs-attr">exec:</span><br><span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,<span class="hljs-string">&quot;echo hello world&quot;</span>]<br><span class="hljs-attr">preStop:</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>可以观察这些配置的位置，Pod的归Pod，容器的归容器。</p><h2 id="Pod-的运行"><a href="#Pod-的运行" class="headerlink" title="Pod 的运行"></a>Pod 的运行</h2><p><img src="/source/public/upload/kubernetes/pod_status.png"></p><h3 id="pod生命周期"><a href="#pod生命周期" class="headerlink" title="pod生命周期"></a>pod生命周期</h3><p>pod的生命周期 <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/">Pod Lifecycle</a>  <a href="https://github.com/kubernetes/kubernetes/blob/master/pkg/kubelet/events/event.go">event.go</a></p><p><img src="/source/public/upload/kubernetes/pod_lifecycle.png"></p><ol><li><p>Pending, API Server已经创建该Pod，且Pod内还有一个或多个容器的镜像没有创建，包括正在下载镜像的过程。</p></li><li><p>Running, Pod内所有容器均已创建，且至少有一个容器处于运行状态、正在启动状态或正在重启状态。</p></li><li><p>Succeeded, Pod内所有容器均成功执行退出，且不会重启。</p></li><li><p>Failed, Pod内所有容器均已退出，但至少有一个容器退出为失败状态。</p></li><li><p>Unknown,  For some reason the state of the Pod could not be obtained, typically due to an error in communicating with the host of the Pod. 用户可以执行 <code>kubectl delete pods &lt;pod&gt; --grace-period=0 --force</code> 强制删除 Pod</p><h3 id="容器状态及其它状态"><a href="#容器状态及其它状态" class="headerlink" title="容器状态及其它状态"></a>容器状态及其它状态</h3><p> restartPolicy 和 Pod 里容器的状态，以及Pod 状态的对应关系（最终体现在<code>kube get pod pod_name</code> 时 status 的状态） <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#example-states">有一系列复杂的情况</a> ，可以概括为两条基本原则：</p><ol><li>只要 Pod 的 restartPolicy 指定的策略允许重启异常的容器（比如：Always），那么这个 Pod 就会保持 Running 状态，并进行容器重启。否则，Pod 就会进入 Failed 状态 。</li><li>对于包含多个容器的 Pod，只有它里面所有的容器都进入异常状态后，Pod 才会进入 Failed 状态。在此之前，Pod都是 Running 状态。此时，Pod 的 READY 字段会显示正常容器的个数</li></ol><p> <a href="https://zhuanlan.zhihu.com/p/34332367">Kubernetes 排错之 Pod 异常</a></p><p> <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy">Restart policy</a>A PodSpec has a restartPolicy field with possible values Always, OnFailure, and Never. The default value is Always. restartPolicy applies to all Containers in the Pod. restartPolicy only refers to restarts of the Containers by the kubelet on the same node. Exited Containers that are restarted by the kubelet are restarted with an exponential back-off delay (10s, 20s, 40s …) capped at five minutes, and is reset after ten minutes of successful execution. <strong>业务容器经常会因为内存不足发生oom，进而导致容器的重启，重启次数可以间接反映业务的健康状态</strong>。</p></li></ol><pre><code class="hljs"><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// k8s.io/kubernetes/pkg/apis/core/types.go</span><br><span class="hljs-keyword">type</span> PodStatus <span class="hljs-keyword">struct</span> &#123;<br>Phase PodPhase<br>Conditions []PodCondition<br>Message <span class="hljs-type">string</span><br>Reason <span class="hljs-type">string</span><br>NominatedNodeName <span class="hljs-type">string</span><br>HostIP <span class="hljs-type">string</span><br>PodIPs []PodIP<br>StartTime *metav1.Time<br>QOSClass PodQOSClass<br>InitContainerStatuses []ContainerStatus<br>ContainerStatuses []ContainerStatus<br>EphemeralContainerStatuses []ContainerStatus<br>&#125;<br></code></pre></td></tr></table></figure>## kubectl drain 发生了什么[Kubernetes Pod 删除操作源码解析](https://mp.weixin.qq.com/s/L-CQhYzxqxOoy9xYp6-JMA)kubectl drain 将以某种方式驱逐 Pod。drain 将向控制平面发出删除目标节点上的 Pod 的请求。通过 API 将 Pod 从集群中删除后，所有发生的事情就是该 Pod 在元数据服务器中被标记为要删除。这会向所有相关子系统发送一个 Pod 删除通知1. 目标节点上的 kubelet 开始关闭 Pod。1. 节点上的 kubelet 将调用 Pod 中的 preStop 勾子。2. 一旦 preStop 勾子完成，节点上的 kubelet 将向 Pod 容器中正在运行的应用程序发出 TERM 信号。3. 节点上的 kubelet 将等待最多宽限期（在 Pod 上指定，或从命令行传递；默认为 30 秒）以关闭容器，然后强行终止进程（使用 SIGKILL）。请注意，此宽限期包括执行 preStop 勾子的时间。2. 所有节点上运行的 kube-proxy 守护程序将从 iptables 中删除 pod 的 ip 地址。3. endpoint 控制器将从有效 endpoint 列表中删除该 Pod，然后从 Service 中删除该 Pod。这里的重点涉及多个系统，这些系统可能在不同的节点上运行，并且这些序列**并行发生**。因此，将 Pod 从所有活动列表中删除之前，Pod 很有可能运行 preStop 钩子并接收到 TERM 信号。## 为什么pod中要有一个pause 容器？[Kubernetes networking 101 – Pods](http://www.dasblinkenlichten.com/kubernetes-networking-101-pods/)all containers within a single pod share the same network namespace. 那么现在假设一个pod定义了三个容器（container1, container2, container3），你如何实现共享网络的效果呢？直接的想法：启动一个容器（比如container1），然后container2、container3 挂在container1上，但这样做有几个问题：1. Pod 里的多个容器就不是对等关系，而是拓扑关系了1. 启动顺序无法保证，正常都是先拉到谁的镜像就先启动哪个2. 假设container1 挂了（比如业务代码问题），则就殃及container2, container3 。3. 尤其container3 还没有启动的时候，container1 挂了，那container3 怎么办呢？the pause container servers as an anchoring point for the pod and make it easy to determine what network namespace the pod containers should join. pause container 被称为 infrastructure container，中文有的文章简称 Infra 容器。Infra 容器一定要占用极少的资源，所以它使用的是一个非常特殊的镜像，叫作：`k8s.gcr.io/pause`。这个镜像是一个用汇编语言编写的、永远处于“暂停”状态的容器，解压后的大小也只有 100~200 KB 左右。PS：代码里start/stopSandbox 就是在操作pause 容器[vivo AI计算平台在线业务落地实践](https://mp.weixin.qq.com/s/nvXm0zEshtOMWrN5mqEHsQ)k8s 给 pod 提供了一个 shareProcessNamespace 特性，可以在 pod 内开启共享 PID 名称空间，将 pod 中的 1 号进程变成了 /pause，并在 /pause 进程中实现了对容器内其他进程的管理，从而避免出现僵尸进程。pod 内其他容器默认情况下不会共享 pause PID Namespace，如果不共享 PID Namespace，那其他容器内的僵尸进程就无法将其父进程变成 pause，pause 自然也回收不了其他容器的僵尸进程。**Pod 最重要的一个事实是：它只是一个逻辑概念。有了Pod，我们可以说Network Namespace和Volume 不是container A 的，也不是Container B的，而是Pod 的。**。[kubectl 创建 Pod 背后到底发生了什么？](https://mp.weixin.qq.com/s/ctdvbasKE-vpLRxDJjwVMw)pause 容器作为同一个 Pod 中所有其他容器的基础容器，它为 Pod 中的每个业务容器提供了大量的 Pod 级别资源，这些资源都是 Linux 命名空间（包括网络命名空间，IPC 命名空间和 PID 命名空间）。## pod不只是一个概念[容器与Pod到底有什么区别和联系？](https://mp.weixin.qq.com/s/N5Vh5_AT_Pl0Und0W-Ljtg)Pod 的 cgroups 是什么样的？systemd-cgls 可以很好地可视化 cgroups 层次结构：<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gradle">$ sudo systemd-cgls<br>Control <span class="hljs-keyword">group</span> /:<br>-.slice<br>├─kubepods<br>│ ├─burstable<br>│ │ ├─pod4a8d5c3e-<span class="hljs-number">3821</span>-<span class="hljs-number">4727</span>-<span class="hljs-number">9</span>d20-<span class="hljs-number">965</span>febbccfbb<br>│ │ │ ├─f0e87a93304666766ab139d52f10ff2b8d4a1e6060fc18f74f28e2cb000da8b2<br>│ │ │ │ └─<span class="hljs-number">4966</span> /pause<br>│ │ │ ├─dfb1cd29ab750064ae89613cb28963353c3360c2df913995af582aebcc4e85d8<br>│ │ │ │ ├─<span class="hljs-number">5001</span> <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/python3 /u</span>sr<span class="hljs-regexp">/local/</span>bin/gunicorn -b <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">80</span> httpbin:app -k gevent<br>│ │ │ │ └─<span class="hljs-number">5016</span> <span class="hljs-regexp">/usr/</span>bin<span class="hljs-regexp">/python3 /u</span>sr<span class="hljs-regexp">/local/</span>bin/gunicorn -b <span class="hljs-number">0.0</span>.<span class="hljs-number">0.0</span>:<span class="hljs-number">80</span> httpbin:app -k gevent<br>│ │ │ └─<span class="hljs-number">097</span>d4fe8a7002d69d6c78899dcf6731d313ce8067ae3f736f252f387582e55ad<br>│ │ │   └─<span class="hljs-number">5035</span> <span class="hljs-regexp">/bin/</span>sleep <span class="hljs-number">3650</span>d<br>...<br></code></pre></td></tr></table></figure>所以，Pod 本身有一个cgroup父节点（Node），每个容器也可以单独调整。Pod 不仅仅是一组容器。Pod 是一个自给自足的高级构造。所有 Pod 的容器都运行在同一台机器（集群节点）上，它们的生命周期是同步的，并且通过削弱隔离性来简化容器间的通信。[Kubernetes 上运行有状态应用的最佳实践](https://mp.weixin.qq.com/s/l3GPCNO4P828Fl_CjaK7WA) 未读。</code></pre>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>golang_...</title>
    <link href="/2022/03/18/golang/"/>
    <url>/2022/03/18/golang/</url>
    
    <content type="html"><![CDATA[<h1 id="go语言-…的用法"><a href="#go语言-…的用法" class="headerlink" title=" go语言 …的用法"></a><center> go语言 …的用法</h1><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul><li><a href="#menuIndex1">背景</a></li><li><a href="#menuIndex2">用法一：不定参传入</a></li><li><a href="#menuIndex3">用法二：切片打散成单个字符串</a></li></ul><h3 id="menuIndex1">背景</h3>初次看go的代码的时候发现很多...的代码使用，好奇这是什么用法。<h3 id="menuIndex2">用法一：不定参传入</h3>第一个用法主要是用于函数有多个不定参数的情况，表示为可变参数，可以接受任意个数但相同类型的参数。比如下面的例子：PrintString函数能接受任意个string参数，然后把它打印出来<pre class="prettyprint linenums"><code><span class="pln">func PrintString(args ...string) &#123;     for _, s:= range args&#123;        fmt.Println(s)    &#125;&#125;</span></code></pre><h3 id="menuIndex3">用法二：切片打散成单个字符串</h3>假设我们定义了一个切片，我们现在需要调用PrintString函数,把切片中的每一个字符串都输出出来，假如没有...语法糖，我们就需要遍历了，但是有了...之后，我们只需要按照下面的示例书写即可<pre class="prettyprint linenums"><code><span class="pln">func main()&#123;var EnumString = []string&#123;        "levon",        "lei",        "kind",        "man",    &#125;    PrintString(EnumString...) //切片被当成多个单字符串传入&#125;</span></code></pre>输出结果<pre class="prettyprint linenums"><code><span class="pln">levonleikindman</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>golang</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
